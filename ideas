Graphs:

Graphs consist of two data types: nodes and edges.

Crush nodes are simply rows in normal tables.

Crush edges are a new type that connect two table rows to each others. Every
edge contains two index references. Edges can be directed or undirected.
Edges can point to the same row or other rows in the same table, but allowing
them to point to rows in other tables would lead to reference cycles and memory
leaks. One-to-one relationships are simply edge fields. One-to-many, and many-to-many
relationships are modeled using fields of lists.

# Find leaf nodes
crush> ps | where { (children:len) == 0 }

A new operator, '::', is used to access a member in each element of a list.

# Find processes who are running as a different user than their parent
ps | where { parent::user != global:user:me:name }

When using '::' on a list/set of edges, it fetches that member in each element in returns them in a new list.

In order to display a graph as a tree, simply return an edge as the root object, and the pretty-printer will
do the rest:

crush> (ps | where {pid == 1}):parent
...


grpc command:

# Create new grpc instance:
crush> srv := (grpc "localhost:443")
# List all services on a server
crush> dir srv
[my.service other.service]
# List all methods of a service
crush> dir srv:my.service
[method1 method2]
# Call method without parameters
srv:my.service:method1
["some" "output"]
# Call method with parameters
srv:my.service:method2 id=1234 tags=(list:of "foo" "bar")
["other" "output"]

Validation:
All commands declare valid input and output types.
Input types can be partial, e.g. any iterator or any iterator with some restrictions.
Checks are performed to validate consistency.
Syntax for not having to duplicate output type.

Commands:
A simple command for replacing a regex in every line of a file. Implement it in crush, using built in commands.
Extra columns for ps: tty, current CPU usage.
du-like command for showing disk usage hierachy.
A grep-command.
read equivalent
Allow simpler column renaming via select, e.g. 'ps|select time=^cpu'
xml:from/to using html5ever under the hood
html:from/to using html5ever under the hood
Add hex and base64 en/decoding methods to the binary/string types
Add utf-8 and other character encoding methods to the binary/string types
Maybe unset should be an operator, so that we don't have to quote the variable name, which feels inconsistent
Maybe unset should only be able to delete members of the current scope
sticky bits support for chmod
recursive chmod
recursive chown
Threads command, shows all threads on the system
watch command

Time to figure out tab completion.
This will eventually require a parser that can parse broken and incomplete input and return some kind of best guess.

Long term completion feature list:

* Completions for wildcards
* Completions for files
* Command specific completions for arguments with a set of allowed values supported out of the box.
* General purpose command specific completions are specified as an extra command
* Command specific completions are specified for the individual argument, as part of the signature.
* Complete only scope members of the right type.
    - if type of argument is a type, only complete with known types
    - Complete with files from current scope only when argument may be a file
* Complete with prior arguments from same command from history
